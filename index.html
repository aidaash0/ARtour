<!DOCTYPE html>
<html>
<head>
    <title>AR Portal with Stencil Buffer</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        .arjs-loader {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .arjs-loader div {
            text-align: center;
            font-size: 1.25em;
            color: white;
        }
    </style>
</head>
<body>
    <div class="arjs-loader">
        <div>Loading, please wait...</div>
    </div>

    <a-scene
        vr-mode-ui="enabled: false;"
        arjs="sourceType: webcam; debugUIEnabled: false;"
        renderer="logarithmicDepthBuffer: true;"
    >
        <a-marker preset="hiro">
            <a-entity id="portal-frame"
                position="0 0.001 0"
                rotation="-90 0 0"
                scale="1 1 1"
                visible="true"
                portal-renderer
            >
                <a-plane
                    id="stencil-plane"
                    width="1"
                    height="1"
                    position="0 0 0.001"
                    material="color: black; transparent: true; opacity: 0;"
                ></a-plane>

                <a-entity id="inner-world-container" visible="false">
                    <a-box position="0 0.5 -1" color="#FF0000"></a-box>
                    <a-sphere position="0.5 0.75 -1.5" radius="0.4" color="#00FF00"></a-sphere>
                    <a-cylinder position="-0.5 0.3 -0.5" radius="0.3" height="0.6" color="#0000FF"></a-cylinder>
                    <a-plane position="0 0 -1" rotation="-90 0 0" width="2" height="2" color="#AAAAAA"></a-plane>
                </a-entity>
            </a-entity>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        AFRAME.registerComponent('portal-renderer', {
            init: function () {
                const el = this.el;
                const sceneEl = el.sceneEl;
                const renderer = sceneEl.renderer;
                const camera = sceneEl.camera;

                // Three.js elements
                const portalFrame = el.object3D;
                const stencilPlaneMesh = document.getElementById('stencil-plane').getObject3D('mesh');
                const innerWorldContainer = document.getElementById('inner-world-container').object3D;

                // --- 1. Set up the inner scene's camera and render target ---
                this.innerCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.innerRenderTarget = new THREE.WebGLRenderTarget(
                    window.innerWidth,
                    window.innerHeight,
                    { stencilBuffer: true, depthBuffer: true } // Ensure stencil buffer is enabled for the render target
                );

                // --- 2. Configure the stencil plane ---
                // This plane will write to the stencil buffer, creating the "hole"
                stencilPlaneMesh.material.colorWrite = false; // Don't write color
                stencilPlaneMesh.material.depthWrite = false; // Don't write depth

                // Configure stencil operations for the stencil plane
                stencilPlaneMesh.onBeforeRender = function (renderer) {
                    renderer.clearDepth(); // Clear depth before rendering stencil mask
                    renderer.clearStencil(); // Clear stencil buffer

                    renderer.state.setStencilTest(true);
                    renderer.state.setStencilFunc(THREE.AlwaysStencilFunc, 1, 0xFF); // Always pass, write 1
                    renderer.state.setStencilOp(THREE.ReplaceStencilOp, THREE.ReplaceStencilOp, THREE.ReplaceStencilOp); // Replace stencil value with 1
                    renderer.state.setStencilWriteMask(0xFF);
                };

                stencilPlaneMesh.onAfterRender = function (renderer) {
                    // After rendering the stencil plane, configure the inner world to only render where stencil is 1
                    renderer.state.setStencilFunc(THREE.EqualStencilFunc, 1, 0xFF); // Only pass if stencil value is 1
                    renderer.state.setStencilOp(THREE.KeepStencilOp, THREE.KeepStencilOp, THREE.KeepStencilOp); // Keep stencil value
                    renderer.state.setStencilWriteMask(0x00); // Don't write to stencil for inner world objects
                    renderer.state.setStencilTest(false); // Reset stencil test for normal rendering
                };

                // Add the inner world container to the marker's object3D.
                // We'll manage its visibility and rendering manually.
                portalFrame.add(innerWorldContainer);

                // Hide inner world initially, we'll draw it to the render target
                innerWorldContainer.visible = false;

                // --- 3. Custom render loop for the portal ---
                this.tick = function () {
                    // Get current camera world position and quaternion
                    const worldPos = new THREE.Vector3();
                    const worldQuat = new THREE.Quaternion();
                    camera.getWorldPosition(worldPos);
                    camera.getWorldQuaternion(worldQuat);

                    // Position the inner camera relative to the portal
                    // This is crucial: the inner camera should be as if it's looking from *inside* the portal
                    // relative to the main camera's view of the portal.
                    // For a simple planar portal, the inner camera essentially mirrors the main camera's
                    // position and rotation relative to the portal frame.
                    const portalWorldPos = new THREE.Vector3();
                    const portalWorldQuat = new THREE.Quaternion();
                    portalFrame.getWorldPosition(portalWorldPos);
                    portalFrame.getWorldQuaternion(portalWorldQuat);

                    // Transform camera position to be relative to the portal frame
                    const cameraLocalPos = portalFrame.worldToLocal(worldPos.clone());
                    this.innerCamera.position.copy(cameraLocalPos);

                    // Transform camera rotation to be relative to the portal frame
                    this.innerCamera.quaternion.copy(worldQuat);
                    this.innerCamera.quaternion.premultiply(portalWorldQuat.invert()); // Adjust for portal's orientation
                    // Invert the Z-axis for the portal "depth" effect if needed.
                    // This creates the illusion of looking "through" to another world.
                    this.innerCamera.rotation.y += Math.PI; // Rotate 180 degrees around Y for mirrored effect
                    this.innerCamera.position.z *= -1; // Mirror Z position

                    this.innerCamera.updateMatrixWorld();

                    // --- Render the inner world to the render target ---
                    renderer.setRenderTarget(this.innerRenderTarget);
                    renderer.state.buffers.depth.setMask(true); // Ensure depth buffer is writable
                    renderer.clear();
                    renderer.render(innerWorldContainer, this.innerCamera); // Render inner world with inner camera

                    // --- Render the main scene (AR content) ---
                    renderer.setRenderTarget(null); // Back to default framebuffer
                    renderer.clearDepth(); // Clear depth for AR elements to render on top
                };

                // When the AR system detects the marker
                sceneEl.addEventListener('arReady', () => {
                    console.log("AR.js is ready!");
                });

                // Set up the scene's onBeforeRender to apply stencil logic
                sceneEl.renderer.autoClear = false; // We will manually clear and control rendering

                // Attach onBeforeRender to the Three.js scene object
                // This ensures our custom rendering logic runs within the A-Frame render loop
                sceneEl.renderer.setClearColor(0x000000, 0); // Transparent background for AR

                const originalRender = sceneEl.renderer.render.bind(sceneEl.renderer);

                sceneEl.renderer.render = (scene, camera) => {
                    // Step 1: Render the stencil plane to mark the portal area
                    renderer.state.buffers.color.setMask(false); // Don't write color
                    renderer.state.buffers.depth.setMask(false); // Don't write depth
                    renderer.state.setStencilTest(true);
                    renderer.state.setStencilFunc(THREE.AlwaysStencilFunc, 1, 0xFF);
                    renderer.state.setStencilOp(THREE.ReplaceStencilOp, THREE.ReplaceStencilOp, THREE.ReplaceStencilOp);
                    renderer.state.setStencilWriteMask(0xFF);

                    renderer.clear(true, true, true); // Clear color, depth, and stencil
                    originalRender(stencilPlaneMesh, camera); // Render only the stencil plane

                    // Step 2: Render the inner world using the render target and stencil
                    renderer.state.buffers.color.setMask(true); // Write color again
                    renderer.state.buffers.depth.setMask(true); // Write depth again
                    renderer.state.setStencilFunc(THREE.EqualStencilFunc, 1, 0xFF); // Only render where stencil is 1
                    renderer.state.setStencilOp(THREE.KeepStencilOp, THREE.KeepStencilOp, THREE.KeepStencilOp);
                    renderer.state.setStencilWriteMask(0x00); // Don't write to stencil

                    // Apply the render target texture to a plane that sits where the portal is
                    stencilPlaneMesh.material.map = this.innerRenderTarget.texture;
                    stencilPlaneMesh.material.opacity = 1; // Make it visible
                    stencilPlaneMesh.material.needsUpdate = true; // Crucial to update material
                    stencilPlaneMesh.material.side = THREE.DoubleSide; // Ensure it's visible from both sides

                    originalRender(innerWorldContainer, this.innerCamera); // Render the inner world with its camera

                    // Step 3: Render the rest of the AR scene (outer world)
                    renderer.state.setStencilTest(false); // Disable stencil test for the rest of the scene
                    renderer.state.setStencilWriteMask(0xFF); // Reset write mask

                    originalRender(scene, camera); // Render the full A-Frame scene
                };
            },
            update: function () {
                // Component update logic if needed
            },
            tick: function () {
                // Ensure the inner camera position is updated relative to the main camera and portal
                // This will be called by A-Frame's tick loop
                const el = this.el;
                const sceneEl = el.sceneEl;
                const camera = sceneEl.camera;
                const portalFrame = el.object3D;
                const innerWorldContainer = document.getElementById('inner-world-container').object3D;

                if (!portalFrame || !innerWorldContainer || !camera || !this.innerCamera) return;

                // Get world positions and rotations
                const mainCameraWorldPos = new THREE.Vector3();
                const mainCameraWorldQuat = new THREE.Quaternion();
                camera.getWorldPosition(mainCameraWorldPos);
                camera.getWorldQuaternion(mainCameraWorldQuat);

                const portalFrameWorldPos = new THREE.Vector3();
                const portalFrameWorldQuat = new THREE.Quaternion();
                portalFrame.getWorldPosition(portalFrameWorldPos);
                portalFrame.getWorldQuaternion(portalFrameWorldQuat);

                // Calculate relative position and rotation of the main camera to the portal
                const relativePos = mainCameraWorldPos.clone().sub(portalFrameWorldPos);
                const relativeQuat = mainCameraWorldQuat.clone().multiply(portalFrameWorldQuat.clone().invert());

                // Set the inner camera's position and rotation based on the relative pose
                // This creates the "looking through" effect.
                // The Z-axis mirroring is key for the portal illusion.
                this.innerCamera.position.set(
                    relativePos.x,
                    relativePos.y,
                    -relativePos.z // Mirror Z
                );
                this.innerCamera.quaternion.copy(relativeQuat);
                this.innerCamera.rotateY(Math.PI); // Rotate 180 degrees around Y for inside-out view

                this.innerCamera.updateMatrixWorld(); // Important to update the camera's matrix
            }
        });
    </script>
</body>
</html>
